2. Определить сложность следующих алгоритмов:

-. Поиск элемента массива с известным индексом 
O(1)


-. Дублирование одномерного массива через foreach 
O(n): нужно пройти все элементы один раз


-. Удаление элемента массива с известным индексом без сдвига 
O(1)


-. Удаление элемента массива с неизвестным индексом без сдвига 
O(n): нужно найти элемент, в лучшем случае он первый O(1), в худшем последний O(n)


-. Удаление элемента массива с неизвестным индексом со сдвигом
O(n): сначала нужно найти элемент O(n), затем сдвинуть каждый, что правее на 1 позицию, 
т.е. сложность двух  операций вместе всегда O(n), в первой части проходим все элементы для поиска, во второй для сдвига.

3. Определить сложность следующих алгоритмов. Сколько произойдет итераций?
a)
        int n = 10000;
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i++) { O(n) 10000
            for (int j = 1; j < n; j *= 2) { O(logn) 14 (2^13=8192, 2^14=16384)
                arrayList.add(i * j);
            }
        }
Сложность O(n*logn). Итераций 10000* 14


b)
        int n = 10000;
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i += 2) { O(n) 5000
            for (int j = i; j < n; j++) { O(n) 10000-i
                arrayList.add(i * j);
            }
        }
Сложность O(n^2). Итераций примерно 5000* 10000/2
на 2 поделил, т.к. j растёт с каждой итерацией, получается треугольная матрица


с)
        int n = 10000;
        List<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < n; i ++) { O(logn) 
            for (int j = 0; j < n; j++) { O(n) 5000
                arrayList.add(i * j);
                n--;
            }
        }
Сложность первого цикла O(logn), т.к. за счёт второго цикла n уменьшается в 2 раза на каждой итерации
Сложность второго цикла O(n), n стремительно уменьшается, но первый раз нужно пройти 0,5*n
Сложность O(n). 
Первый цикл выполнится не более 13 раз (2^14=16348)

13 член прогрессии с коэф 0.5 равняется 5000*0.5^13=0.610
Сумма первых 13 членов 5000*(0.5^12-1)/(0.5-1)=9997

Итераций примерно 9997


d)
```
    factorial(BigInteger.valueOf(10000))

public static BigInteger factorial(BigInteger n) {
    if (n.equals(BigInteger.ONE)) {
        return n;
    }
    return n.multiply(factorial(n.subtract(BigInteger.valueOf(1))));
}

Сложность O(n). Количество итераций равно числу для которого необходимо вычислить факториал,
т.к. функция вызывает сама себя один раз уменьшая входное число на 1.


e)

fib(BigInteger.valueOf(50));

public static BigInteger fib(BigInteger n) {
    if (n.equals(BigInteger.ONE)) {
        return BigInteger.ONE;
    }
    if (n.equals(BigInteger.TWO)) {
        return BigInteger.ONE;
    }
    return fib(n.subtract(BigInteger.ONE)).add(fib(n.subtract(BigInteger.TWO)));
}

Сложность O(2^n) Каждый вызов приводит к двум другим вызовам и далее каждый двоится.
